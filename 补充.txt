
  
  	
	function getJSON(url){
		var promis = new Promise((succ,error)=>{
			var ajax = new XMLHttpRequest();
			ajax.open('get',url);
			ajax.send();
			
			ajax.onload = function(){
				if(ajax.status>=200 && ajax.status <= 207 ){
					succ(ajax.responseText);
				}else{
					error(ajax.status)
				}
			}
		});
		return promis;
	}
	
	/*
		有三种状态：
		Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）
		
	*/
	cript type="text/javascript">
	
	/*
		ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 
		
		add(value)：添加某个值，返回Set结构本身。
		delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
		has(value)：返回一个布尔值，表示该值是否为Set的成员。
		clear()：清除所有成员，没有返回值。
		
	*/
	//	var arr = [1,2,3,2,1,4,5,6,6];
//	
//	console.log(...new Set(arr))
//	
//	console.log([...new Set(arr)]);

	const s = new Set();
	
	
	s.add(1)
	
	console.log(s.has(1)); //只能判断简单类型是否被Set包含	/*
		Object.assign：
			方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
	*/
		
//	console.log(new Array(3)); //length为3

	//Array.of方法用于将一组值，转换为数组。
	//console.log(Array.of(3)); // [3]
	
	
	//copyWithin
	
	//上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。
//	console.log([1, 2, 3, 4, 5].copyWithin(0, 3));
	
//	console.log([1, 2, 3, 4, 5].copyWithin(0, 2));

	//console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4))
	
//	console.log([1, 2, 3, 4, 5].copyWithin(2, 2, 3));

//	console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4))//42345


//	var arr = [{id:1},{id:2},{id:3},{id:4}]; 
//	
//	console.log(arr.find((e)=> e.id==2)); //找到复合条件的并且返回出来
//	
//	
//	console.log(arr.findIndex((e)=> e.id==2));


	/*
		for of 只能在有Symbol.iterator遍历接口的数据下遍历，没有就不能使用
		
		默认，数组和字符串有遍历接口
		
	*/
	var arr = [1,2,3,4];
	var obj = {};
	let str = 'miaov';
	
	//console.dir(new String)
	
	console.dir(arr);
	
	
	/*
		keys，得到的是数组中的key值 
	*/
	
//	for(var i of arr.keys()){
//		console.log(i);
//	}

	/*
		entries:可以读取到key和val
	*/
	for(var [key,val] of arr.entries()){
		console.log(key,val)
	}
		
	//console.log(Number.parseInt('110',2));  //第二个参数是把某进制转10进制
	
	
//	console.log(isNaN('x'));//true
	
	console.log(Number.isNaN('x'*1));//只认括号中是不是NaN,不乘1就是false
	
	//isNaN(Number.MAX_VALUE)   false
	//isNaN(Infinity) false
	