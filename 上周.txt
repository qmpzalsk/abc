	
	btn.onclick = function(){
		
		var ajax = new XMLHttpRequest(); //new了个电话出来
		
		ajax.open('get','php/get.php?user='+user.value,true);//3个参数,拨号
		
		ajax.send(); //按绿色按钮
		
		ajax.onload = function(){ //等待
			
			span.innerHTML = ajax.responseText; //通话
			
		}

	}
		
	user.onblur = function(){
		var ajax = new XMLHttpRequest;
		
		ajax.open('get','php/get_json.php?user='+encodeURI(this.value));
		
		ajax.send();
		
		ajax.onload = function(){
			//把json格式转成对象，这个时候js才能更好的操作。
			var data = JSON.parse(ajax.responseText); //'{}'
			
			if(data.code){
				user.className = 'red';
			}else{
				user.className = 'green';
			}

			//console.log();
			span.innerHTML = data.msg;
		}
		
	}
	
		
	var user = document.getElementById('user');
	var span = document.getElementById('span');
	
	user.onblur = function(){
		var ajax = new XMLHttpRequest();
		
		ajax.open('post','php/post.php');
		
		ajax.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
		ajax.send('user='+this.value);
		
		ajax.onload = function(){
			//console.log(ajax.responseText)
			//alert(1);
			
			span.innerHTML = ajax.responseText;
		}
	}	
	user.onclick = function(){
		const ajax = new XMLHttpRequest;
		
		ajax.open('get','php/data.xml');

		ajax.send();
		
		ajax.onload = function(){
			//console.log( ajax.responseXML );
			
			var data = ajax.responseXML;
			
			var persons =  data.getElementsByTagName('person');
			
			for(var i=0;i<persons.length;i++){
				var li = document.createElement('li');
				var child = persons[i].children;
				li.innerHTML = `${child[0].innerHTML}今年${child[1].innerHTML}岁,性别:${child[2].innerHTML}--- 他说:${child[3].innerHTML}`;
				
				ul.appendChild(li);
			};
			//console.log(persons);
		}
	}
		
	user.onblur = function(){
		
		const ajax = new XMLHttpRequest;
		
		ajax.open('post','php/post.php');
		
		ajax.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
		
		ajax.send('user='+this.value);
		
		ajax.onload = function(){
			span.innerHTML = ajax.responseText;
		}
		
	}
	
		/*
		eval:
			能够将字符串尽可能的转成js代码并且运行。
	*/<script type="text/javascript">
	/*
		页面上所有的静态资源都是同步的
		
		同步:从上而下，依次解读，只要中间运行不了，下面就不执行
		
		异步:从上而下,如果中间运行不了，下面依然执行。
		
	*/
		/*
		http状态码：
			200-207是成功
			
			4开头全是错误
			
			5开头找后端（跟你没关系）
			
			ajax.status  可以查看本次请求的状态码
	*/
		/*
		onload:在IE9以下浏览器不兼容 
		
		onreadystatechange存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。
		
		0-4  数字   只要数字到了4，说明整个请求过程完毕
		0监控不到的，因为第0步是创建
	*/
			
		ajax({
			url:'php/post2.php',
			method:'post',
			//url:'php/data.xml',
//			url:'php/get_json.php',
			data:{
				user:user.value
			},
			//dataType:'xml',
			dataType:'str',
			success:function(obj){
				
				console.log(obj);
				span.innerHTML = obj;  
//				if(obj.code){
//					user.className = 'red';
//				}else{
//					user.className = 'green';
//				}
//				span.innerHTML = obj.msg;
			},
			error:function(obj){
				console.log(obj.readyState)
				alert(obj.status);
			}
		});
		
	}
	/*
		ajax、jsonp、模板引擎、本地存储、cookie、流行框架
		node、很多小例子（跟接口有关）....
		
		
		跨域（跨出了某个区域范围）跨源。
		
		源:
			域名、端口、协议
			
	同源策略（Same origin policy）是一种约定，
		它是浏览器最核心也最基本的安全功能，
		如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。
		可以说Web是构建在同源策略基础之上的，
		浏览器只是针对同源策略的一种实现。
			
		上网过程中，最最最害怕的就是安全问题。	
		
		taobao.com
		baidu.com
		jd.com
		miaov.com
		
		域名：只是ip地址的一个别名，主要为了好记。
			比如百度ip：http://119.75.217.109/
				xx网站 :http://140.205.220.96/
		
		端口：
			可以认为是设备与外界通讯交流的出口（专门办某件事的窗口）
		协议：
			file:本地协议
			http（网络协议）/https（网络协议带安全证书）
			ftp（文件传输协议）
		
		
		同源:
			同域名、同协议、同端口
			
		跨域：
			不同源就叫跨域。
	*/
		
	/*
		解决跨域问题有很多：
			1.在高版本浏览器下，可以通过XMLHttpRequest
				配合后端设置一个请求头并且给权限。
			
			<?php
				//header('Access-Control-Allow-Origin:*');
				echo 'hello';
			
			我跟张是同一个局域网，我输入他的ip可以访问他的文件
			
			但是，用我的ip去访问他的文件就跨域
			
			2.服务器代理
			
				
				自身的文件与服务器的文件在同域，
				所以自身可以直接访问服务器文件，
				服务器文件可以直接访问到外域的文件，
				
				等同于自身的文件能访问外域的文件。
				
				弊端：
					东西始终是别人的，别人变了，你的自身的也变了
					
			3.iframe跨域
			
			4.flash跨域
			
			5.jsonp
			
	*/
		
	/*
		解决跨域问题有很多：
			1.在高版本浏览器下，可以通过XMLHttpRequest
				配合后端设置一个请求头并且给权限。
			
			<?php
				//header('Access-Control-Allow-Origin:*');
				echo 'hello';
			
			我跟张是同一个局域网，我输入他的ip可以访问他的文件
			
			但是，用我的ip去访问他的文件就跨域
			
			2.服务器代理
			
			
				
	*/
		/*
		json + padding = jsonp 
		
		如果去访问一个变量那么，下面script标签可以查找上面script标签，但是上面如果没有，那么就报错了，而预解析只是在一个script中执行。
	
		iframe ->src
		link -> href
		img -> src 
		
		
		script ->src 专门解析js的代码 (jsonp的关键标签)
		
		原理(下面2个条件是必须的)：
		
			1.数据必须为函数名+(),数据为实参
			
			2.前端页面中的***全局下***，要有一个对应数据的函数
			
		
		fn({"name":"leo"});
		
		
	*/
	
		/*
			如何区分接口是jsonp的还是ajax的 
				1.接口有没有回调函数字段
				2.拿到数据之后，在浏览器上看看，是否有函数名+括号的
	*/
	
	$.getJSON('http://www.wookmark.com/api/json/popular?callback=?',function(arr){
		console.log(arr);
		$.each(arr,function(i,e){
			var div = $(`<div class="pic">
				<img src="${e.preview}"/>
			</div>`);
			
			$('li').eq(minHeight()).append(div);
			
		});
		
	});
	
	function minHeight(){
		var max = Infinity;
		var index = 0;
		$('li').each((i,e)=>{
			if(e.scrollHeight < max){
				max = e.scrollHeight;
				index = i;
			}
		});
		
		return index;
	}
	
	
	/*
		同源：
			同域名、同端口、同协议
			
		跨源请求：
			不同源
		
		1.高版本浏览器XMLHttpRequest配合后端设置header权限
		
		2.服务器代理
		
		3.iframe的src
		
		4.flash
		
		5.jsonp
		
		
		json + padding    fn({})
		
		全局要放一个跟数据对应的函数
		
		***静态的资源都是同步，
		
		***创建script标签并且插入，它的异步操作。
		
		
		jsonp实现原理是什么？
		
			通过创建script标签动态添加到页面（因为script标签会解析js代码），相当于说调用全局的函数，将数据传入到
			函数的实参中（说明数据必须是函数名+()的数据才能使用jsonp），全局的函数就可以直接拿到实参的数据了，从而实现跨域请求
		
		
	*/
	
	
	
	
	document.onclick = function(){
		var oS = document.createElement('script');
		oS.src = 'http://localhost/2017-5-25/1.data.php';
		document.getElementsByTagName('head')[0].appendChild(oS);
	}
	
	
	function fn1(data){
		console.log(data);
	}
		
	/*
		cookie（必须放在服务器环境下）:
			自定义属性,获取出来的都是字符串。
			
		指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据.
		设置之后会存在浏览器的缓存中并且浏览器调试工具可以捕捉到。
		
		cookie体积在低版本浏览器下是字字千金。
		
		一般来说每个域有50个左右限制
		
		设置：
			document.cookie = xx
			
			document.cookie = key=value
			
		生命周期：
			默认的生命周期为本次浏览器关闭之前
			不同的浏览器不共享cookie	
			
	*/
		
	/*
		cookie（必须放在服务器环境下）:
			自定义属性,获取出来的都是字符串。
			
		指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据.
		设置之后会存在浏览器的缓存中并且浏览器调试工具可以捕捉到。
		
		cookie体积在低版本浏览器下是字字千金。
		
		一般来说每个域有50个左右限制
		
		设置：
			document.cookie = xx
			
			document.cookie = key=value
			
		生命周期：
			默认的生命周期为本次浏览器关闭之前
			不同的浏览器不共享cookie
			
			
				
	/*
		cookie:它本身不是前端技术，但是现在很多处理cookie都由前端搞
		
		最大的缺点就是小。
		
		只要是前端的东西都不安全。
		
		localStorage:
			目前有5M，但是以后应该还会扩充
		
		setItem(key,val)  设置本地存储的数据
		getItem(key)  获取本地存储的数据
		removeItem(key)  删除本地存储的数据
		
		clear():清空本地存储的数据
		
		生命周期：
			只要你不删永远在！
			
		
				
	*/
	//	localStorage

	localStorage.setItem('name','小明');
	localStorage.setItem('name1','小明');
	localStorage.setItem('name2','小明');
	
//	console.log(localStorage.getItem('name'))

	//localStorage.removeItem('name');
	
	
	localStorage.clear();
	
	console.dir(localStorage);
	
		/*
		操作本地的方法，跟localStorage一样
		
		区别：
			1.生命周期（当关闭浏览器之后，生命结束）
			2.不支持storage事件
			
		一般是5M	
		
		jsonp的数据ajax有可能拿得到，
		
		但是ajax的数据一定拿不到。
		
	*/
		
	/*
		storage:
			**当前页面绑定**这个事件之后，如果在浏览器上删除本地数据，就会在**当前页面**触发这个事件 
			
		storage这个事件更擅长通过操作本地数据来通知当前浏览器的除自身的其他兄弟页面。
		前提条件是在兄弟页面在一个域中才能操作。
			
			
	*/
		
	/*
		storage:
			**当前页面绑定**这个事件之后，如果在浏览器上删除本地数据，就会在**当前页面**触发这个事件 
			
		storage这个事件更擅长通过操作本地数据来通知当前浏览器的其他兄弟页面。
		前提条件是在兄弟页面在一个域中才能操作。
			
			
	*/
	
	
	var btns = document.querySelectorAll('button');
	
	btns[0].onclick = function(){
		localStorage.setItem('age',23);
	}
	
	btns[1].onclick = function(){
		localStorage.removeItem('age');
	}
	
	window.addEventListener("storage",function(){
		console.log(123);
	},false)
	
	